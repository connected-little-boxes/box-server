<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.3.1/dist/css/bootstrap.min.css"
    integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
  <title>Connected Little Boxes</title>
</head>

<body>
  <div class="container mb-4">
    <h3 class="mt-2 mb-2">
      <%= name %>
    </h3>
    <h1 class="mb-4">Connected Little Boxes</h1>
    <h2 class="mb-2">Configure device</h2>
    <div class="container mb-4">
      <form onsubmit="doSubmit(event)">
        <div class="form-group mt-4">
          <label for="wifissid">WiFi SSID:</label>
          <input type="text" id="wifissid" name="wifissid" required class="form-control">
        </div>
        <div>
          <label for="wifipwd">WiFi Password:</label>
          <input type="password" id="wifipwd" name="wifipwd" required class="form-control">
        </div>
        <button onclick=doSubmit() class="btn btn-success mb-4 mt-4 btn-block">Save</button>`
      </form>
    </div>
  </div>

  <script src="/js/esptool/ESPManager.js"></script>
  <script src="/js/esptool/ESPToolJS.js"></script>
  <script src="/js/esptool/ESP32.js"></script>
  <script src="/js/esptool/ESP8266.js"></script>
  <script src="/js/esptool/SerialManager.js"></script>
  <script src="/js/esptool/stubs.js"></script>
  <script src="/js/simpleterm/terminal.js"></script>

  <script>

    class BoxCommander {

      constructor() {
        this.port = null;
        this.reader = null;
        this.handleIncomingText = null;
        this.lineBuffer = "";
        this.command = "";
        this.gotCommandBack = false;
      }

      async connectToSerialPort() {

        if (!"serial" in navigator) {
          this.port = null;
          return "This browser doesn't support serial connection. Try Edge or Chrome.";
        }

        try {
          this.port = await navigator.serial.requestPort();
          await this.port.open({ baudRate: 115200, bufferSize: 10000 });
        }
        catch (error) {
          return "Serial port open failed:" + error.message;
        }

        return "";
      }

      handleCommand(text) {
        console.log("Got a reply:" + text + " " + text.length);
        if (this.gotCommandBack) {
          this.command = "";
          // this is the response to the command
          if (text == "done") {
            console.log("command complete");
            this.kept(text);
          }
          else {
            this.broken(text);
          }
        }
        if (text == this.command) {
          this.gotCommandBack = true;
        }
      }

      performCommand(command) {
        console.log("Performing:" + command);
        const commandPromise = new Promise((kept, broken) => {
          if (this.command != "") {
            broken("Command already active:" + command);
          }
          else {
            this.kept = kept;
            this.broken = broken;
            this.command = command;
            this.gotCommandBack = false;
            this.sendText(command + '\n\r');
          }
        });

        const timeout = 5000;

        const timeoutPromise = new Promise((kept, broken) => {
          setTimeout(() => {
            broken(`Operation timed out after ${timeout} ms`);
          }, timeout);
        });

        return Promise.race([commandPromise, timeoutPromise]);
      }

      async performCommands(commands) {
        for (let i = 0; i < commands.length; i++) {
          const command = commands[i];
          await this.performCommand(command);
        }
      }

      async writeUint8Array(valArray) {
        const writer = this.port.writable.getWriter();
        await writer.write(valArray);
        writer.releaseLock();
      }

      async sendText(text) {
        let bytes = new TextEncoder("utf-8").encode(text);
        await this.writeUint8Array(bytes);
      }

      handleIncomingBytes(bytes) {
        var text = new TextDecoder("utf-8").decode(bytes);
        for (let i = 0; i < text.length; i++) {
          const ch = text[i];
          if (ch == '\n') {
            if (this.lineBuffer.length > 0) {
              this.handleCommand(this.lineBuffer);
              this.lineBuffer = "";
            }
          }
          else {
            if (ch != '\r') {
              this.lineBuffer = this.lineBuffer + text[i];
            }
          }
        }
      }

      async pumpReceivedCharacters() {
        while (this.port.readable && this.keepReading) {
          this.reader = this.port.readable.getReader();
          try {
            while (true) {
              const { value, done } = await this.reader.read();
              if (done) {
                break;
              }
              // value is a Uint8Array.
              this.handleIncomingBytes(value);
            }
          } catch (error) {
            console.log(`Serial error:${error.message}`);
          } finally {
            // Allow the serial port to be closed later.
            this.reader.releaseLock();
          }
        }
        await this.port.close();
      }

      async disconnect() {
        if (this.port == null || this.keepReading == false) {
          return;
        }
        this.keepReading = false;

        if (this.reader != null) {
          this.reader.cancel();
        }
      }

      async startSerialPump(destination) {
        this.keepReading = true;
        this.handleIncomingText = destination;
        await this.pumpReceivedCharacters();
        return "Serial disconnected";
      }
    }

    let commander = null;

    let textHandlerFunction = null;

    function handleIncomingText(text) {
      console.log(`Received:${text}`)
      if (textHandlerFunction != null) {
        textHandlerFunction(text);
      }
    }

    async function doSubmit(event) {
      try {
        event.preventDefault();
      }
      catch (e) {
        return;
      }

      if (commander == null) {
        commander = new BoxCommander();
        let result;
        result = await commander.connectToSerialPort();
        if (result != "") {
          alert("Could not continue: " + result);
          return;
        }
        else {
          commander.startSerialPump(handleIncomingText);
        }
      }
      await commander.performCommands(["pixelname=simonx", "pixelname=jim", "pixelname=rob"]).then(() => console.log("Commands complete"));
      console.log("Click");
    }


  </script>
</body>

</html>